# 1

## WebGL
보통 3D 그래픽 렌더링을 위해 사용된다. 뛰어난 성능을 가지지만 low-api 수준으로 개발자가 기초적인 것부터 개발해야한다. Three.js는 WebGL을 위한 자바스크립트 프레임워크다.

## 모듈방식
three.js는 모듈 방식의 개발을 추천하고 더 많은 기능을 지원하고 있다. `three.module.js` 모듈 파일을 다운로드하고 import해 와서 사용한다.

## 웹팩
번들러는 이미지 파일, 자바스크립트 파일, css 파일 등을 배포할 때 병합하고 포장하는 일을 한다. 그 중에 가장 잘 알려진 것이 웹팩이다. 바벨을 로더로 사용해서 최신 자바스크립트 버전을 하위 버전과 호환될 수 있게 트랜스파일링 한다. 수업은 웹팩을 활용해서 진행된다. 수업에서는 css파일과 이미지 파일은 그대로 복사해오고 js 파일만 번들링하고 있다. 발생가능한 오류를 줄이기 위함이다. 웹팩에 대한 이해도가 낮은 상태에서는 오류를 해결하는데 시간이 오래 걸릴 수도 있기 때문이다. 

## 빌드
npm run build 명령어를 통해서 빌드를 하면 웹팩에서 설정한대로 /dist 파일에 배포용 파일이 만들어진다. 빌드된 파일을 업로드하면 배포를 할 수 있다.

Q.
웹팩 버전에서는 빌드 하지 않으면 live server를 구동해도 main.js 파일에 있는 three 파일이 실행되지 않는다.

Q.
CRA/next.js라는 프레임워크 위에서 웹팩 설정을 따로 하지 않고 사이트를 개발해왔다보니, 설정을 따로 하는 게 조금은 까다롭게 느껴진다. 리액트를 활용하지 않아서 html, css 파일을 따로 작성하는 부분이나, 클래스 문법, 돔을 조작하는 방법 등이 조금은 낯설게 느껴진다. 하지만 개발 공부를 하다보면 계속 마주하게 되는 부분이라, 이번에 이 방식으로 코드를 짜면서 충분히 익숙해지는 것도 좋을 것 같다.

# 2

## 기본 장면 구성 요소
- Scene(장면/무대)에 모든 오브젝트가 올라간다. 전체 요소들이 포함되는 공간이다.
- Mesh는 오브젝트를 일컫는 말로, Geometry(모양)와 Material(재질)로 구성된다. 
- Camera는 시야각(얼마나 넓게 볼 수 있는지)을 갖고 있다. 
- Light는 재질에 따라 필요할 수도 있고 아닐 수도 있다. 빛이 있어야 보이는 재질이 있다.
- Renderer는 최종적으로 보여지는 장면인데, 카메라가 어떤 위치에서 어느 정도의 시야각으로 Scene을 비추고 있는지에 따라 달라진다.
- 3차원은 x/y/z(앞, 뒤) 축을 갖고 있다. 


## 장면과 카메라
- `원근 카메라`에는 4개의 매개변수를 전달할 수 있다. 시야각, 종횡비, near, far를 숫자로 전달한다. 수업에서는 일단 주어진 수를 적었는데, 실제 화면을 통해 봐야 뭔지 알 수 있을 것 같다. 
- mesh가 near와 far사이에 있고 시야각(fov) 안에 들어와야 눈에 보인다.
- 카메라의 위치를 설정해줄 때, camera.position.z = 5라는 코드를 넣었다. 우리가 씬에 올리고 있는 메쉬에 따라 단위를 다르게 상정할 수 있을텐데, 이번에 미터로 상정하고 넣어주면 편하다. x, y , z 값을 변경해줄 때마다 카메라맨이 움직이는 것으로 이해할 수 있다.
- `직교 카메라`는 6개의 매개변수를 전달하는데, 절두체의 left, right, top, bottom, near, far 값을 준다. 원근법이 무시된다.
- 카메라 위치의 z 값을 변경해줄 때, 원근법이 적용되지 않고 모양을 바라보는 뷰가 바뀌게 된다. zoom을 사용해주면 된다.
- `lookAt()` 메소드를 사용해서 mesh를 바라보지 않게 하면 화면에 나타나지 않게 된다.


## Mesh
- 카메라의 포지션을 x/y/z 축으로 움직여줌에 따라서 렌더링 되는 오브젝트의 면이 달라진다.
- antialias 속성 사용
- 정리 : 렌더러(캔버스) 만들기 -> scene을 만들고 그 위에 mesh와 camera를 만들어 만들어 scene에 추가하기 -> 최종적으로 렌더러로 scene과 camera를 그려준다.

## 창사이즈 변경 대응하기
- 창 크기가 변하는 이벤트가 발생하면 호출되는 함수를 만들어서 카메라의 종횡비를 변경하고 업데이트하고 렌더러의 사이즈를 변경해주고 렌더러에 그린다.
- 캔버스를 고해상도를 표현하고 싶으면 이미지와 마찬가지로 뷰포트에 100px로 보여준다고 하면 실제 물리적인 크기는 2배로 크게 만들고(집적도*) 100px로 줄여서 보여준다. `devicePixelRatio` 값을 renderer에 전달해준다. 

## 배경색
- `renderer`를 조작하는 방법과 `scene`을 조작하는 방법 두 가지가 있는데, 동시에 적용하면 scene에 적용된 색상이 최종적으로 덮어씌워진다.

## 조명
- BasicMaterial은 빛이 없어도 보이고 영향을 받지 않아서 StandardMaterial로 바꿔주었다.
- 두 번째로 전달되는 인자는 빛의 강도이다.
- 빛은 무대에 여러개를 넣을 수 있지만 성능에는 악영향을 미칠 수 있다.

## 애니메이션
- Three.js에서 `requestAnimationFrame`을 사용한다. 이 기능이 내재된 메소드도 있다. 브라우저가 리페인트하기 전에 해당 애니메이션을 업데이트해준다.
- draw라는 함수를 따로 만들어서 그 안에서 `requestAnimationFrame` 메소드를 호출하는데 그 안에 draw 함수를 전달해서 무한 반복된다.

## 애니메이션 성능보정
- 사용자의 기기에 따라 애니메이션에 버벅거림이 있을 수 있다. 위의 draw 함수 호출 횟수가 달라질 수 있다. Three.js가 제공하는 Clock 메소드를 활용해서 횟수를 찍어볼 수 있다.
- degree가 아니라 절대시간(`ElapsedTime`)을 대신 넣어준다. 성능이 느린 컴퓨터는 draw 함수가 호출되는 시간의 텀이 늘어나게 된다. 절대 시간을 넣어주면 프레임수는 다를 수 있어도 똑같은 애니메이션 속도를 볼 수 있게 된다. (논리가 완전히 이해되지는 않는다.)
- `delta`라는 시간차를 이용할 수도 있다.
- 자바스크립트의 `Date.now()`를 사용해서 시간차를 구할 수도 있다. Three.js와 관계없이 통용될 수 있다.

## 안개 
- scene에 fog 속성을 이용해서 색과 안개의 범위를 설정하는 near, far를 인자로 전달해주면 된다.
- 안개의 색을 배경색과 동일하게 해주면 훨씬 입체감 있게 보인다.
- 반복문으로 만든 meshes 배열에 forEach 함수를 이용해서 애니메이션을 동일하게 적용해주었다.

## 외부 라이브러리 사용 (애니메이션)
- `Gsap`을 사용해서 기존에 잘 만들어진 애니메이션 라이브러리를 사용하는 것도 방법이다. (전세계에서 가장 많이 사용되고 있음)
- 유료 버전도 있지만, 기본 무료 버전을 수업에서 사용한다.

## npm, webpack 사용하지 않고 진행하기
- 모듈을 사용하거나 모듈도 사용하지 않는 두 가지 경우를 해봤다. 모듈을 사용하는 편을 추천한다.
- 모듈 사용하는 경우 
  - 스크립트 태그로 js파일 추가해주기
  - three.module.js 파일 import 해오기
  - OrbitControls을 사용할 때, 웹사이트에서 다운로드 받은 jsm 파일을 에디터로 가져와서 사용했다.
  - 에러발생)웹사이트에서는 기본적으로 웹팩 사용을 기준으로 코드가 적혀있는데, OrbitControls에서 모듈 방식으로 파일경로 설정을 다시 해줘야했다.

# 3

## AxesHelper, GridHelper
- 시각적인 가이드를 제공해준다. `AxesHelper`는 x/y/z축을 나타내는 선을 보여주고 `GridHelper`는 격자무늬를 보여준다.

## 초당 프레임 수 보기(Stats)
- 외부 라이브러리를 설치해서 작업하는 페이지의 성능을 확인해볼 수 있다. FPS 숫자가 낮을수록 성능이 떨어진다.

## GUI 컨트롤
- 카메라와 메쉬의 position을 코드가 아니라 GUI로 테스트 해볼 수 있는 외부 라이브러리 사용하기
- 컨트롤할 대상과 속성, 범위, 단위를 넣어줄 수 있다.
- three.js 외에도 다양하게 활용할 수 있다.

# 4

## 위치 position
- x, y, z 속성을 한꺼번에 설정하는 `set()` 메소드를 사용할 수 있다.
- vector3는 3차원 공간에서의 한 점을 말한다.
- `length()`, `distanceTo()` 메소드를 활용해보았다.

## 크기 scale
- position과 마찬가지로 scale도 `set()` 메소드를 사용할 수 있다. position과 유사하다.

## 회전
- rotation 속성에 값을 줄 때, 라디안 값으로 줘야 한다. 두 가지 방법이 있는데 THREE.js의 내장 함수인 `degToRad()`를 사용할 수도 있고, `Math.PI`를 180도를 기준으로 계산할 수도 있다. 혹은 그냥 숫자 `1`을 적을 수도 있다. 60도가 안 되는 각도다. 혹은 `delta`값을 넣어줘서 애니메이션 성능 보정을 할 수도 있다.
- 게임 캐릭터가 고개를 옆으로 45도 틀고 하늘을 향해 20도 바라보길 원할 때, 작성하는 코드. 축을 재정의해주는 `reorder(YXZ)`메소드를 사용했다. (좀 더 이해가 필요함)
- 수업에서는 축을 바꾸고 20도라고 했는데 -20도로 해야 고개를 드는 모양이 되는 거 아닐까 생각이 든다. 

## 그룹 만들기
- 메쉬를 그룹으로 묶어서 한꺼번에 조작할 수 있다. 그룹으로 묶어서 움직일 때 연산을 편하게 할 수 있다.
- 태양, 지구, 달 태양계의 움직임을 그룹 만들기 기능으로 편하게 구현하는 예시 (스스로 이 아이디어를 떠올리려고 했다면 조금 어려웠을 것 같다. 그룹으로 묶으면 A의 자전으로 B의 공전을 동시에 나타내줄 수 있다.)
- `clone()` 메소드를 사용해서 mesh를 복제할 수 있다.
- 지구의 자전속도와 달의 공전속도를 동일하게 만든다면 이렇게 할 수 있겠지만, 그렇지 않다면?

# 5

## Geometry
- `OrbitContorls` 추가로 import 해 와서 사용했다. 마우스를 통해 카메라를 자유롭게 움직일 수 있다.
- `material` 속성에 `wireframe` 불리언 값을 true로 설정하게 되면, 뼈대가 보여서 모양을 파악하기에 쉽다.
- `side`속성에서 DoubleSide 속성으로 변경하면, 카메라가 상자 안에 들어갔을 때, 메쉬가 사라진 것처럼 보이지 않고 안 쪽 면도 보이게 된다.
- `segment` 속성이 있는데 면을 얼마나 많이 쪼갤 수 있는지 설정할 수 있다. wireframe 속성을 추가해야만 보인다. 그렇다면 쓰임새는? 버텍스(정점)이 추가된 셈인데 그 좌표를 이용해서 애니메이션 효과를 만들 수 있다.
- 공식문서에서 다양한 geometry를 확인해볼 수 있고 GUI controls를 조절하면서 인자로 전달되는 값에 따라 도형이 어떻게 변화하는지 시각적으로 바로 보여준다.
- 모양이 들어가는 경우 blender 같은 3D 모델링 소프트웨어로 만들지만 three.js가 제공하는 기본적인 geometry를 조합해서 그룹핑해서 만들기도 한다. 

## Vertex에 접근해서 애니메이션 효과 주기
- 구를 만든 후에 material 속성에 `flatShading` 속성을 true라고 주면, 폴리곤처럼 각지게 변화한다. 
- `geometry.attributes.position.array`를 콘솔창에 찍어보니 숫자로 이루어진 수많은 원소를 가진 typed array가 나타난다. 원소를 3개씩 끊어서 한 점의 x/y/z 좌표 값이라고 생각하면 된다.
- 반복문을 사용해 3개씩 묶은 원소의 값에 접근해 패턴을 만든다.
- 애니메이션으로 만들기 위해 변화하는 값을 렌더링해준다. 그런데 Math.random()의 값도 변화하는 값 아닌가? `mesh.rotation.y += Math.random() * 0.01`; 이렇게 코드를 작성해줬을 때는 애니메이션이 생긴다. for문에서는 왜 애니메이션이 생기지 않을까? 아, 강의 후반부에 이유가 나온다. `update하는 코드`를 넣어준다. 
- 삼각함수 `사인/코사인 그래프`를 활용해서 정점에 애니메이션을 줬다. 사인그래프에서 y값이 파동처럼 오르락 내리락 한다. y값 자체를 늘리면 움직이는 범위가 달라지고 sin 그래프에 전달하는 x값이 늘어나는 크기를 크게 하면 움직임이 빨라진다.* 
- draw()함수는 1초에도 수십번 호출되는 함수이기 때문에, 랜덤한 값을 그 안에 만들지 않고 positionArray와 1:1 대응하는 randomArray를 만들어서 그 값을 사용했다.* 그 때마다 랜덤한 값이 만들어지면 안 되니까. 다시 음미해보니 이 부분이 이해가 간다.
- `고민` : 1초에 수십번씩 연속적으로 실행되는 함수 안에 반복문이라니.. 성능의 문제는 없을까? 이 성능 문제는 어떻게 개선할 수 있나? 반복문 말고 좀 더 효율적으로 랜덤한 값을 주는 코드를 짤 수는 없나?

# 6

## 카메라 컨트롤
- 제공해주는 기능을 쉽게 사용할 수 있다. 다만, 제공되지 않는 컨트롤 기능을 추가하고자 할 때 까다로울 수 있다. 컨트롤 자체를 새로 만들지 혹은 이미 만들어진 것에 추가할 지 결정해야한다.
- 메쉬를 여러개 만들면서 색깔을 다르게 하기 위해서 materials를 만들 때 반복문을 돌렸다. mesh라는 변수를 만들고 반복문을 돌려서 scene.add(mesh) 처리를 해주니 그대로 생긴다. `변수이름은 반복되어도 상관이 없나보다.` 
- `rgb 값`에서 0으로 가까워질수록 색이 어두워진다. 검은색에 가까워진다. 50 - 255의 숫자를 랜덤으로 만들어 주기 위한 코드 참고할만하다. 50을 기본값으로 준다.
-`개인학습` : 정육면체를 무한대로 만들고 position을 윈도우창의 width/height 크기로 흩뿌려주니, 밤하늘에 별처럼 보인다. 아름답다.

## OrbitControls
- `enableDamping` 컨트롤을 부드럽게 만들어준다. draw()함수에 `controls.update()` 메소드를 넣어주어야 한다.
- `enableZoom`은 줌을 못하게 만든다.
- `min/maxDistance`는 최소/최대 거리에 한정을 주는 메소드다.
- `minPolarAngle/maxPolarAngle`는 수직방향으로 카메라의 각도 조절의 최소/최대 리밋을 이야기한다. min은 기본값이 0이고, max는 기본값이 180도이다. 반원 모양의 각도기가 있다고 생각하고 왼편/오른편 선이 있다고 생각해볼까?
- `controls.target.set(2, 2, 2)` 설정한 좌표를 중심축으로 움직인다.
- `autoRotate` 설정으로 true로 하게 되면 저절로 카메라가 회전한다. Speed 값을 조절하는 속성도 있다.

## TrackballControls
- OrbinControls과 거의 흡사하고 커다란 차이점이 있다면, 수직으로 360도 회전이 가능하다. `enableDamping`이 기본적으로 적용이 되어 있다.
- `controls.update()` 코드를 써주지 않으면 적동이 안 된다.

