# 1

## WebGL
보통 3D 그래픽 렌더링을 위해 사용된다. 뛰어난 성능을 가지지만 low-api 수준으로 개발자가 기초적인 것부터 개발해야한다. Three.js는 WebGL을 위한 자바스크립트 프레임워크다.

## 모듈방식
three.js는 모듈 방식의 개발을 추천하고 더 많은 기능을 지원하고 있다. `three.module.js` 모듈 파일을 다운로드하고 import해 와서 사용한다.

## 웹팩
번들러는 이미지 파일, 자바스크립트 파일, css 파일 등을 배포할 때 병합하고 포장하는 일을 한다. 그 중에 가장 잘 알려진 것이 웹팩이다. 바벨을 로더로 사용해서 최신 자바스크립트 버전을 하위 버전과 호환될 수 있게 트랜스파일링 한다. 수업은 웹팩을 활용해서 진행된다. 수업에서는 css파일과 이미지 파일은 그대로 복사해오고 js 파일만 번들링하고 있다. 발생가능한 오류를 줄이기 위함이다. 웹팩에 대한 이해도가 낮은 상태에서는 오류를 해결하는데 시간이 오래 걸릴 수도 있기 때문이다. 

## 빌드
npm run build 명령어를 통해서 빌드를 하면 웹팩에서 설정한대로 /dist 파일에 배포용 파일이 만들어진다. 빌드된 파일을 업로드하면 배포를 할 수 있다.

Q.
웹팩 버전에서는 빌드 하지 않으면 live server를 구동해도 main.js 파일에 있는 three 파일이 실행되지 않는다.

Q.
CRA/next.js라는 프레임워크 위에서 웹팩 설정을 따로 하지 않고 사이트를 개발해왔다보니, 설정을 따로 하는 게 조금은 까다롭게 느껴진다. 리액트를 활용하지 않아서 html, css 파일을 따로 작성하는 부분이나, 클래스 문법, 돔을 조작하는 방법 등이 조금은 낯설게 느껴진다. 하지만 개발 공부를 하다보면 계속 마주하게 되는 부분이라, 이번에 이 방식으로 코드를 짜면서 충분히 익숙해지는 것도 좋을 것 같다.

# 2

## 기본 장면 구성 요소
- Scene(장면/무대)에 모든 오브젝트가 올라간다. 전체 요소들이 포함되는 공간이다.
- Mesh는 오브젝트를 일컫는 말로, Geometry(모양)와 Material(재질)로 구성된다. 
- Camera는 시야각(얼마나 넓게 볼 수 있는지)을 갖고 있다. 
- Light는 재질에 따라 필요할 수도 있고 아닐 수도 있다. 빛이 있어야 보이는 재질이 있다.
- Renderer는 최종적으로 보여지는 장면인데, 카메라가 어떤 위치에서 어느 정도의 시야각으로 Scene을 비추고 있는지에 따라 달라진다.
- 3차원은 x/y/z(앞, 뒤) 축을 갖고 있다. 


## 장면과 카메라
- `원근 카메라`에는 4개의 매개변수를 전달할 수 있다. 시야각, 종횡비, near, far를 숫자로 전달한다. 수업에서는 일단 주어진 수를 적었는데, 실제 화면을 통해 봐야 뭔지 알 수 있을 것 같다. 
- mesh가 near와 far사이에 있고 시야각(fov) 안에 들어와야 눈에 보인다.
- 카메라의 위치를 설정해줄 때, camera.position.z = 5라는 코드를 넣었다. 우리가 씬에 올리고 있는 메쉬에 따라 단위를 다르게 상정할 수 있을텐데, 이번에 미터로 상정하고 넣어주면 편하다. x, y , z 값을 변경해줄 때마다 카메라맨이 움직이는 것으로 이해할 수 있다.
- `직교 카메라`는 6개의 매개변수를 전달하는데, 절두체의 left, right, top, bottom, near, far 값을 준다. 원근법이 무시된다.
- 카메라 위치의 z 값을 변경해줄 때, 원근법이 적용되지 않고 모양을 바라보는 뷰가 바뀌게 된다. zoom을 사용해주면 된다.
- `lookAt()` 메소드를 사용해서 mesh를 바라보지 않게 하면 화면에 나타나지 않게 된다.


## Mesh
- 카메라의 포지션을 x/y/z 축으로 움직여줌에 따라서 렌더링 되는 오브젝트의 면이 달라진다.
- antialias 속성 사용
- 정리 : 렌더러(캔버스) 만들기 -> scene을 만들고 그 위에 mesh와 camera를 만들어 만들어 scene에 추가하기 -> 최종적으로 렌더러로 scene과 camera를 그려준다.

## 창사이즈 변경 대응하기
- 창 크기가 변하는 이벤트가 발생하면 호출되는 함수를 만들어서 카메라의 종횡비를 변경하고 업데이트하고 렌더러의 사이즈를 변경해주고 렌더러에 그린다.
- 캔버스를 고해상도를 표현하고 싶으면 이미지와 마찬가지로 뷰포트에 100px로 보여준다고 하면 실제 물리적인 크기는 2배로 크게 만들고(집적도*) 100px로 줄여서 보여준다. `devicePixelRatio` 값을 renderer에 전달해준다. 

## 배경색
- `renderer`를 조작하는 방법과 `scene`을 조작하는 방법 두 가지가 있는데, 동시에 적용하면 scene에 적용된 색상이 최종적으로 덮어씌워진다.

## 조명
- BasicMaterial은 빛이 없어도 보이고 영향을 받지 않아서 StandardMaterial로 바꿔주었다.
- 두 번째로 전달되는 인자는 빛의 강도이다.
- 빛은 무대에 여러개를 넣을 수 있지만 성능에는 악영향을 미칠 수 있다.

## 애니메이션
- Three.js에서 `requestAnimationFrame`을 사용한다. 이 기능이 내재된 메소드도 있다. 브라우저가 리페인트하기 전에 해당 애니메이션을 업데이트해준다.
- draw라는 함수를 따로 만들어서 그 안에서 `requestAnimationFrame` 메소드를 호출하는데 그 안에 draw 함수를 전달해서 무한 반복된다.

## 애니메이션 성능보정
- 사용자의 기기에 따라 애니메이션에 버벅거림이 있을 수 있다. 위의 draw 함수 호출 횟수가 달라질 수 있다. Three.js가 제공하는 Clock 메소드를 활용해서 횟수를 찍어볼 수 있다.
- degree가 아니라 절대시간(`ElapsedTime`)을 대신 넣어준다. 성능이 느린 컴퓨터는 draw 함수가 호출되는 시간의 텀이 늘어나게 된다. 절대 시간을 넣어주면 프레임수는 다를 수 있어도 똑같은 애니메이션 속도를 볼 수 있게 된다. (논리가 완전히 이해되지는 않는다.)
- `delta`라는 시간차를 이용할 수도 있다.
- 자바스크립트의 `Date.now()`를 사용해서 시간차를 구할 수도 있다. Three.js와 관계없이 통용될 수 있다.

## 안개 
- scene에 fog 속성을 이용해서 색과 안개의 범위를 설정하는 near, far를 인자로 전달해주면 된다.
- 안개의 색을 배경색과 동일하게 해주면 훨씬 입체감 있게 보인다.
- 반복문으로 만든 meshes 배열에 forEach 함수를 이용해서 애니메이션을 동일하게 적용해주었다.

## 외부 라이브러리 사용 (애니메이션)
- `Gsap`을 사용해서 기존에 잘 만들어진 애니메이션 라이브러리를 사용하는 것도 방법이다. (전세계에서 가장 많이 사용되고 있음)
- 유료 버전도 있지만, 기본 무료 버전을 수업에서 사용한다.

## npm, webpack 사용하지 않고 진행하기
- 모듈을 사용하거나 모듈도 사용하지 않는 두 가지 경우를 해봤다. 모듈을 사용하는 편을 추천한다.
- 모듈 사용하는 경우 
  - 스크립트 태그로 js파일 추가해주기
  - three.module.js 파일 import 해오기
  - OrbitControls을 사용할 때, 웹사이트에서 다운로드 받은 jsm 파일을 에디터로 가져와서 사용했다.
  - 에러발생)웹사이트에서는 기본적으로 웹팩 사용을 기준으로 코드가 적혀있는데, OrbitControls에서 모듈 방식으로 파일경로 설정을 다시 해줘야했다.

  # 3

## AxesHelper, GridHelper
- 시각적인 가이드를 제공해준다. `AxesHelper`는 x/y/z축을 나타내는 선을 보여주고 `GridHelper`는 격자무늬를 보여준다.

## 초당 프레임 수 보기(Stats)
- 외부 라이브러리를 설치해서 작업하는 페이지의 성능을 확인해볼 수 있다. FPS 숫자가 낮을수록 성능이 떨어진다.

## GUI 컨트롤
- 카메라와 메쉬의 position을 코드가 아니라 GUI로 테스트 해볼 수 있는 외부 라이브러리 사용하기
- 컨트롤할 대상과 속성, 범위, 단위를 넣어줄 수 있다.
- three.js 외에도 다양하게 활용할 수 있다.