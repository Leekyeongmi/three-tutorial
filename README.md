# 2

## 기본 장면 구성 요소
- Scene(장면/무대)에 모든 오브젝트가 올라간다. 전체 요소들이 포함되는 공간이다.
- Mesh는 오브젝트를 일컫는 말로, Geometry(모양)와 Material(재질)로 구성된다. 
- Camera는 시야각(얼마나 넓게 볼 수 있는지)을 갖고 있다. 
- Light는 재질에 따라 필요할 수도 있고 아닐 수도 있다. 빛이 있어야 보이는 재질이 있다.
- Renderer는 최종적으로 보여지는 장면인데, 카메라가 어떤 위치에서 어느 정도의 시야각으로 Scene을 비추고 있는지에 따라 달라진다.
- 3차원은 x/y/z(앞, 뒤) 축을 갖고 있다. 


## 장면과 카메라
- `원근 카메라`에는 4개의 매개변수를 전달할 수 있다. 시야각, 종횡비, near, far를 숫자로 전달한다. 수업에서는 일단 주어진 수를 적었는데, 실제 화면을 통해 봐야 뭔지 알 수 있을 것 같다. 
- mesh가 near와 far사이에 있고 시야각(fov) 안에 들어와야 눈에 보인다.
- 카메라의 위치를 설정해줄 때, camera.position.z = 5라는 코드를 넣었다. 우리가 씬에 올리고 있는 메쉬에 따라 단위를 다르게 상정할 수 있을텐데, 이번에 미터로 상정하고 넣어주면 편하다. x, y , z 값을 변경해줄 때마다 카메라맨이 움직이는 것으로 이해할 수 있다.
- `직교 카메라`는 6개의 매개변수를 전달하는데, 절두체의 left, right, top, bottom, near, far 값을 준다. 원근법이 무시된다.
- 카메라 위치의 z 값을 변경해줄 때, 원근법이 적용되지 않고 모양을 바라보는 뷰가 바뀌게 된다. zoom을 사용해주면 된다.
- `lookAt()` 메소드를 사용해서 mesh를 바라보지 않게 하면 화면에 나타나지 않게 된다.



## Mesh
- 카메라의 포지션을 x/y/z 축으로 움직여줌에 따라서 렌더링 되는 오브젝트의 면이 달라진다.
- antialias 속성 사용
- 정리 : 렌더러(캔버스) 만들기 -> scene을 만들고 그 위에 mesh와 camera를 만들어 만들어 scene에 추가하기 -> 최종적으로 렌더러로 scene과 camera를 그려준다.

## 창사이즈 변경 대응하기
- 창 크기가 변하는 이벤트가 발생하면 호출되는 함수를 만들어서 카메라의 종횡비를 변경하고 업데이트하고 렌더러의 사이즈를 변경해주고 렌더러에 그린다.
- 캔버스를 고해상도를 표현하고 싶으면 이미지와 마찬가지로 뷰포트에 100px로 보여준다고 하면 실제 물리적인 크기는 2배로 크게 만들고(집적도*) 100px로 줄여서 보여준다. `devicePixelRatio` 값을 renderer에 전달해준다. 

## 배경색
- `renderer`를 조작하는 방법과 `scene`을 조작하는 방법 두 가지가 있는데, 동시에 적용하면 scene에 적용된 색상이 최종적으로 덮어씌워진다.

## 조명
- BasicMaterial은 빛이 없어도 보이고 영향을 받지 않아서 StandardMaterial로 바꿔주었다.
- 두 번째로 전달되는 인자는 빛의 강도이다.
- 빛은 무대에 여러개를 넣을 수 있지만 성능에는 악영향을 미칠 수 있다.

## 애니메이션
- Three.js에서 `requestAnimationFrame`을 사용한다. 이 기능이 내재된 메소드도 있다. 브라우저가 리페인트하기 전에 해당 애니메이션을 업데이트해준다.
- draw라는 함수를 따로 만들어서 그 안에서 `requestAnimationFrame` 메소드를 호출하는데 그 안에 draw 함수를 전달해서 무한 반복된다.

## 애니메이션 성능보정
- 사용자의 기기에 따라 애니메이션에 버벅거림이 있을 수 있다. 위의 draw 함수 호출 횟수가 달라질 수 있다. Three.js가 제공하는 Clock 메소드를 활용해서 횟수를 찍어볼 수 있다.
- degree가 아니라 절대시간(`ElapsedTime`)을 대신 넣어준다. 성능이 느린 컴퓨터는 draw 함수가 호출되는 시간의 텀이 늘어나게 된다. 절대 시간을 넣어주면 프레임수는 다를 수 있어도 똑같은 애니메이션 속도를 볼 수 있게 된다. (논리가 완전히 이해되지는 않는다.)
- `delta`라는 시간차를 이용할 수도 있다.
- 자바스크립트의 `Date.now()`를 사용해서 시간차를 구할 수도 있다. 

## 안개 
- scene에 fog 속성을 이용해서 색과 안개의 범위를 설정하는 near, far를 인자로 전달해주면 된다.
- 안개의 색을 배경색과 동일하게 해주면 훨씬 입체감 있게 보인다.
- 반복문으로 만든 meshes 배열에 forEach 함수를 이용해서 애니메이션을 동일하게 적용해주었다.